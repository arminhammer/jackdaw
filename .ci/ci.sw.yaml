document:
  dsl: '1.0.2'
  namespace: ci
  name: jackdaw-ci
  version: '1.0.0'
  description: 'CI pipeline for jackdaw - leveraging jackdaw itself for CI execution'

use:
  catalogs:
    local:
      endpoint:
        uri: file://./.ci/catalog

do:
  # Step 1: Compute file hashes for cache invalidation
  - computeHashes:
      call: compute-hashes:1.0.0
      with:
        categories:
          rust_sources:
            patterns:
              - 'src/**/*.rs'
              - 'Cargo.toml'
              - 'Cargo.lock'
          sql_schemas:
            patterns:
              - 'sql/**/*.sql'
          ci_workflows:
            patterns:
              - '.ci/**/*.yaml'
              - '.ci/**/*.py'
          all_sources:
            patterns:
              - 'src/**/*.rs'
              - 'Cargo.toml'
              - 'Cargo.lock'
              - 'sql/**/*.sql'
        workflow_id: "ci-run"
      output:
        as:
          computed_hash: ${ .stdout }

  - formatCheck:
      input:
        from: .computed_hash
      run:
        shell:
          command: cargo
          arguments:
            - fmt
            - --check

  # Lint check - clippy
  - clippyCheck:
      input:
        from: .computed_hash
      run:
        shell:
          command: cargo
          arguments:
            - clippy
            - --
            - -D
            - warnings

  #         # Unit tests
  #         - unitTests:
  #             input:
  #               from: "{ rust_sources_hash: .rust_sources }"
  #             run:
  #               shell:
  #                 command: cargo
  #                 arguments:
  #                   - test

  #         # CTK conformance tests
  #         - ctkTests:
  #             input:
  #               from: "{ rust_sources_hash: .rust_sources }"
  #             run:
  #               shell:
  #                 command: cargo
  #                 arguments:
  #                   - test
  #                   - --test
  #                   - ctk_conformance

  #         # Listener tests
  #         - listenerTests:
  #             input:
  #               from: "{ rust_sources_hash: .rust_sources }"
  #             run:
  #               shell:
  #                 command: cargo
  #                 arguments:
  #                   - test
  #                   - --test
  #                   - listener_tests

  #         # Nested workflow tests
  #         - nestedWorkflowTests:
  #             input:
  #               from: "{ rust_sources_hash: .rust_sources }"
  #             run:
  #               shell:
  #                 command: cargo
  #                 arguments:
  #                   - test
  #                   - --test
  #                   - nested_workflow_tests

  #         # Build release binary
  #         - buildRelease:
  #             input:
  #               from: "{ all_sources_hash: .all_sources }"
  #             run:
  #               shell:
  #                 command: cargo
  #                 arguments:
  #                   - build
  #                   - --release

  # # Step 3: Verify build artifacts
  # - verifyArtifacts:
  #     call: check-artifacts:1.0.0
  #     with:
  #       binary_path: target/release/jackdaw

  # # Step 4: Archive artifacts (can be used by GitHub Actions)
  # - archiveArtifacts:
  #     run:
  #       shell:
  #         command: tar
  #         arguments:
  #           - czf
  #           - ci-artifacts.tar.gz
  #           - target/release/jackdaw
  #           - .ci/*.db
  #     if: ${ .verifyArtifacts.valid }

  # # Step 5: Generate CI report
  # - generateReport:
  #     call: generate-report:1.0.0
  #     with:
  #       tasks: ${ .runCITasks }
  #       artifacts: ${ .verifyArtifacts }
  #     output:
  #       as: .ci_report
